package main

const MaxLights = 128
// Lights restore detail more aggressively near sources but never exceed base.
const BaseLightScale = 4
// Darkening strength per dark source; tuned to avoid over-darkening at low night levels
const DarkScale      = 1
// Additive glow-ball parameters
const HaloRadiusFrac    = 0.35
const BaseHaloStrength  = 0.3

var (
    LightCount int
    DarkCount int
    LightPosX [MaxLights]float
    LightPosY [MaxLights]float
    LightRadius [MaxLights]float
    LightR [MaxLights]float
    LightG [MaxLights]float
    LightB [MaxLights]float
    LightIntensity [MaxLights]float
    DarkPosX [MaxLights]float
    DarkPosY [MaxLights]float
    DarkRadius [MaxLights]float
    DarkAlpha [MaxLights]float
    DarkIntensity [MaxLights]float
    LightStrength float
    GlowStrength float
    NightFactor float
)

func Fragment(pos vec4, texCoord vec2, color vec4) vec4 {
    // Base sprite color
    base := imageSrc0At(texCoord)

    // Accumulate darkening multiplicatively (subtractive only)
    dim := vec3(1.0, 1.0, 1.0)
    for i := 0; i < MaxLights; i++ {
        if i < DarkCount {
            dx := pos.x - DarkPosX[i]
            dy := pos.y - DarkPosY[i]
            dist := sqrt(dx*dx + dy*dy)
            nd := dist / DarkRadius[i]
            f := 1.0 / (1.0 + nd*nd)
            d := clamp(DarkScale*DarkAlpha[i]*f, 0.0, 1.0) * DarkIntensity[i]
            dim *= vec3(1.0 - d)
        }
    }
    col := vec4(base.rgb*dim, base.a)

    // Compute a scalar reveal factor and a normalized color mix for smoother blending.
    // This avoids per-channel "patchwork" reveals and blends light colors proportionally.
    sumW := 0.0
    sumC := vec3(0.0, 0.0, 0.0)
    sumCraw := vec3(0.0, 0.0, 0.0)
    // Perceptual luma weights (sRGB)
    lumW := vec3(0.2126, 0.7152, 0.0722)
    // How much to equalize per-light color by luma so
    // low-luma hues (blue) aren't dominated by high-luma (yellow)
    chromaEQ := 0.03
    for i := 0; i < MaxLights; i++ {
        if i < LightCount {
            dx := pos.x - LightPosX[i]
            dy := pos.y - LightPosY[i]
            dist := sqrt(dx*dx + dy*dy)
            nd := dist / LightRadius[i]
            f := 1.0 / (1.0 + nd*nd)
            // Sharper falloff to localize light influence
            f = f * f
            w := clamp(BaseLightScale*LightStrength*f, 0.0, 10.0) * LightIntensity[i]
            sumW += w
            rgb := vec3(LightR[i], LightG[i], LightB[i])
            // Equalize by luminance to balance hue influence
            lum := max(dot(rgb, lumW), 0.001)
            normRGB := rgb / lum
            eqRGB := mix(rgb, normRGB, chromaEQ)
            sumC += w * eqRGB
            sumCraw += w * rgb
        }
    }

    // Tone map reveal to [0, 1) with a Reinhard-like curve
    reveal := sumW / (1.0 + sumW)
    // Gate reveal by night, reaching full power at 50% night
    nf := clamp(NightFactor, 0.0, 1.0)
    revealNF := clamp(nf * 2.0, 0.0, 1.0)
    reveal = reveal * revealNF

    // Normalized light color mix; default to white if no light
    mixColor := vec3(1.0, 1.0, 1.0)
    if sumW > 0.0001 {
        // If the combined light is close to neutral white, reduce chroma equalization
        // to let white mix more naturally with colored lights.
        rawMix := sumCraw / sumW
        cmax := max(rawMix.r, max(rawMix.g, rawMix.b))
        cmin := min(rawMix.r, min(rawMix.g, rawMix.b))
        avg := (rawMix.r + rawMix.g + rawMix.b) / 3.0
        // A crude saturation proxy; higher means more chroma, lower means whiter
        sat := 0.0
        if avg > 0.0001 {
            sat = clamp((cmax - cmin) / avg, 0.0, 1.0)
        }
        whiteness := 1.0 - sat
        // Blend between equalized and raw sums based on whiteness
        sumAdj := mix(sumC, sumCraw, whiteness)
        mixColor = sumAdj / sumW
    }

    // Limit tint strength so base palette remains readable
    // Reduce tinting when overall light is very white to avoid washing colors.
    tintStrength := 0.6
    if sumW > 0.0001 {
        rawMix := sumCraw / sumW
        cmax := max(rawMix.r, max(rawMix.g, rawMix.b))
        cmin := min(rawMix.r, min(rawMix.g, rawMix.b))
        avg := (rawMix.r + rawMix.g + rawMix.b) / 3.0
        sat := 0.0
        if avg > 0.0001 {
            sat = clamp((cmax - cmin) / avg, 0.0, 1.0)
        }
        whiteness := 1.0 - sat
        tintStrength = mix(tintStrength, 0.45, whiteness)
    }
    tintedBase := base.rgb * mix(vec3(1.0, 1.0, 1.0), mixColor, tintStrength)

    // Reveal from darkened color toward tinted base using scalar reveal
    finalRGB := mix(col.rgb, tintedBase, reveal)

    // Small additive halo for compact glow near light centers
    halo := vec3(0.0, 0.0, 0.0)
    for i := 0; i < MaxLights; i++ {
        if i < LightCount {
            dx := pos.x - LightPosX[i]
            dy := pos.y - LightPosY[i]
            r := max(LightRadius[i] * HaloRadiusFrac, 1.0)
            nd := sqrt(dx*dx + dy*dy) / r
            h := 1.0 / (1.0 + nd*nd)
            // Sharpen falloff for a tight inner glow
            h = h * h * h
            halo += LightIntensity[i] * h * vec3(LightR[i], LightG[i], LightB[i])
        }
    }
    // Tone-map halo and add with small strength
    halo = halo / (1.0 + halo)
    finalRGB = clamp(finalRGB + BaseHaloStrength*GlowStrength*halo, 0.0, 1.0)

    return vec4(finalRGB, base.a)
}
